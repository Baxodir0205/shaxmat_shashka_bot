<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shashka Pro Animated</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; font-family: sans-serif; -webkit-tap-highlight-color: transparent; }
        body { background: #1a1a1a; display: flex; justify-content: center; align-items: center; min-height: 100vh; color: white; }
        .game-container { width: 100%; max-width: 400px; background: #262421; border-radius: 12px; padding: 15px; }

        .board-wrapper {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: #312e2b;
            padding: 2px;
            border-radius: 4px;
            margin: 15px 0;
            position: relative;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
        }
        .cell { width: 100%; height: 100%; position: relative; cursor: pointer; }
        .cell.light { background: #ebecd0; }
        .cell.dark { background: #779556; }
        .cell.selected { background: #f6f669 !important; }

        .piece {
            width: 11%;
            height: 11%;
            border-radius: 50%;
            position: absolute;
            z-index: 10;
            transition: all 0.4s cubic-bezier(0.45, 0.05, 0.55, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        .piece.white { background: #fff; border: 3px solid #ccc; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .piece.black { background: #333; border: 3px solid #000; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        .piece.king::after { content: "â˜…"; color: gold; font-size: 20px; }

        .hint::after { content: ""; width: 25%; height: 25%; background: rgba(0,0,0,0.2); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        .status-box { background: #312e2b; padding: 10px; border-radius: 8px; text-align: center; font-weight: bold; border-bottom: 2px solid #7fa650; }
        .btn-main-group { display: flex; gap: 8px; }
        .btn-action { flex: 1; padding: 12px; border: none; border-radius: 8px; font-weight: bold; background: #45423e; color: white; cursor: pointer; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 100; justify-content: center; align-items: center; }
        .modal-content { background: #262421; padding: 20px; border-radius: 12px; width: 80%; text-align: center; }
        .level-btn { display: block; width: 100%; padding: 12px; margin: 8px 0; border-radius: 6px; border: none; background: #312e2b; color: white; font-weight: bold; }
    </style>
</head>
<body>

<div class="game-container">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <span id="currentLevelDisplay" style="color: #aaa; font-size: 14px;">Daraja: Oson</span>
        <button onclick="toggleModal(true)" style="background: #7fa650; border: none; padding: 5px 10px; color: white; border-radius: 4px; font-size: 12px;">DARAJA</button>
    </div>
    <div class="status-box" id="status">Sizning navbatingiz</div>
    <div class="board-wrapper" id="boardWrapper">
        <div id="board" class="board"></div>
    </div>
    <div class="btn-main-group">
        <button class="btn-action" onclick="resetGame()">Yangi o'yin</button>
        <button class="btn-action" style="color: #ff7675;" onclick="tg.close()">Chiqish</button>
    </div>
</div>

<div id="levelModal" class="modal">
    <div class="modal-content">
        <h3 style="color: #7fa650; margin-bottom: 15px;">AI QIYINLIGI</h3>
        <button class="level-btn" onclick="selectLevel(1, 'Oson')">Oson</button>
        <button class="level-btn" onclick="selectLevel(2, 'O\'rtacha')">O'rtacha</button>
        <button class="level-btn" onclick="selectLevel(3, 'Qiyin')">Qiyin</button>
        <button class="level-btn" onclick="selectLevel(4, 'Grandmaster')">Grandmaster</button>
        <button class="level-btn" style="background: #7fa650;" onclick="toggleModal(false)">Yopish</button>
    </div>
</div>

<script>
    const tg = window.Telegram.WebApp; tg.expand();
    let board = [], selectedCell = null, turn = 'white', currentLevel = 1, hints = [], mustJump = false;

    function initBoard() {
        board = Array(8).fill(null).map(() => Array(8).fill(null));
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if ((r + c) % 2 !== 0) {
                    if (r < 3) board[r][c] = { c: 'black', k: false, id: `p-b-${r}-${c}` };
                    else if (r > 4) board[r][c] = { c: 'white', k: false, id: `p-w-${r}-${c}` };
                }
            }
        }
        checkGlobalMustJump();
    }

    function renderBoard() {
        const boardEl = document.getElementById('board');
        const wrapper = document.getElementById('boardWrapper');
        boardEl.innerHTML = '';

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const cell = document.createElement('div');
                cell.className = `cell ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                if (selectedCell?.r === r && selectedCell?.c === c) cell.classList.add('selected');
                if (hints.some(h => h.tr === r && h.tc === c)) cell.classList.add('hint');
                cell.onclick = () => handleClick(r, c);
                boardEl.appendChild(cell);
            }
        }

        const currentIds = [];
        for(let r=0; r<8; r++) for(let c=0; c<8; c++) if(board[r][c]) currentIds.push(board[r][c].id);

        document.querySelectorAll('.piece').forEach(p => {
            if(!currentIds.includes(p.id)) p.remove();
        });

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const pData = board[r][c];
                if (pData) {
                    let pEl = document.getElementById(pData.id);
                    if (!pEl) {
                        pEl = document.createElement('div');
                        pEl.id = pData.id;
                        wrapper.appendChild(pEl);
                    }
                    pEl.className = `piece ${pData.c} ${pData.k ? 'king' : ''}`;
                    pEl.style.left = (c * 12.5 + 0.7) + "%";
                    pEl.style.top = (r * 12.5 + 0.7) + "%";
                }
            }
        }
    }

    function checkGlobalMustJump() {
        mustJump = false;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (board[r][c]?.c === turn) {
                    const moves = getPieceMoves(r, c);
                    if (moves.some(m => m.jump)) { mustJump = true; return; }
                }
            }
        }
    }

    function getPieceMoves(r, c) {
        const p = board[r][c]; if (!p) return [];
        let moves = [];
        const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

        dirs.forEach(d => {
            if (p.k) {
                let nr = r + d[0], nc = c + d[1];
                let enemyPos = null;
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                    if (!board[nr][nc]) {
                        if (!enemyPos) {
                            if (!mustJump) moves.push({ tr: nr, tc: nc, jump: null });
                        } else {
                            moves.push({ tr: nr, tc: nc, jump: { ...enemyPos } });
                        }
                    } else {
                        if (board[nr][nc].c === p.c) break;
                        if (enemyPos) break;
                        enemyPos = { r: nr, c: nc };
                    }
                    nr += d[0]; nc += d[1];
                }
            } else {
                if (!mustJump) {
                    const forward = p.c === 'white' ? -1 : 1;
                    if (d[0] === forward) {
                        let nr = r + d[0], nc = c + d[1];
                        if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !board[nr][nc]) {
                            moves.push({ tr: nr, tc: nc, jump: null });
                        }
                    }
                }
                let nr = r + d[0], nc = c + d[1];
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && board[nr][nc] && board[nr][nc].c !== p.c) {
                    let jr = nr + d[0], jc = nc + d[1];
                    if (jr >= 0 && jr < 8 && jc >= 0 && jc < 8 && !board[jr][jc]) {
                        moves.push({ tr: jr, tc: jc, jump: { r: nr, c: nc } });
                    }
                }
            }
        });
        if (mustJump) moves = moves.filter(m => m.jump);
        return moves;
    }

    function handleClick(r, c) {
        if (turn !== 'white') return;
        if (board[r][c]?.c === 'white') {
            selectedCell = { r, c };
            hints = getPieceMoves(r, c);
        } else if (selectedCell) {
            const move = hints.find(h => h.tr === r && h.tc === c);
            if (move) executeMove(selectedCell.r, selectedCell.c, move);
        }
        renderBoard();
    }

    function executeMove(fr, fc, move) {
        const piece = board[fr][fc];
        board[move.tr][move.tc] = piece;
        board[fr][fc] = null;

        if (move.jump) {
            board[move.jump.r][move.jump.c] = null;
        }

        if ((move.tr === 0 && piece.c === 'white') || (move.tr === 7 && piece.c === 'black')) piece.k = true;

        renderBoard();

        if (move.jump) {
            mustJump = true;
            const nextJumps = getPieceMoves(move.tr, move.tc).filter(m => m.jump);
            if (nextJumps.length > 0) {
                selectedCell = { r: move.tr, c: move.tc };
                hints = nextJumps;
                renderBoard();

                if (turn === 'black') {
                    setTimeout(() => {
                        let nextBestMove = nextJumps[Math.floor(Math.random() * nextJumps.length)];
                        executeMove(move.tr, move.tc, nextBestMove);
                    }, 500);
                }
                return;
            }
        }

        setTimeout(() => {
            turn = turn === 'white' ? 'black' : 'white';
            selectedCell = null; hints = [];
            checkGlobalMustJump();
            const statusEl = document.getElementById('status');
            if (turn === 'black') {
                statusEl.innerText = "AI o'ylamoqda...";
                // Interfeys yozuvni ko'rsatib ulgurishi uchun kichik tanaffus bilan AIni ishga tushiramiz
                setTimeout(aiMove, 50);
            } else {
                statusEl.innerText = "Sizning navbatingiz";
            }
            renderBoard();
        }, 300);
    }

    // --- STRATEGIK SUN'IY INTELLEKT (MINIMAX) ---

    function getSimulatedPieceMoves(b, r, c) {
        const p = b[r][c];
        let moves = [];
        const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        dirs.forEach(d => {
            if (p.k) {
                let nr = r + d[0], nc = c + d[1];
                let enemyPos = null;
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                    if (!b[nr][nc]) {
                        if (!enemyPos) moves.push({ tr: nr, tc: nc, jump: null });
                        else moves.push({ tr: nr, tc: nc, jump: { ...enemyPos } });
                    } else {
                        if (b[nr][nc].c === p.c) break;
                        if (enemyPos) break;
                        enemyPos = { r: nr, c: nc };
                    }
                    nr += d[0]; nc += d[1];
                }
            } else {
                const forward = p.c === 'white' ? -1 : 1;
                if (d[0] === forward) {
                    let nr = r + d[0], nc = c + d[1];
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !b[nr][nc]) {
                        moves.push({ tr: nr, tc: nc, jump: null });
                    }
                }
                let nr = r + d[0], nc = c + d[1];
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && b[nr][nc] && b[nr][nc].c !== p.c) {
                    let jr = nr + d[0], jc = nc + d[1];
                    if (jr >= 0 && jr < 8 && jc >= 0 && jc < 8 && !b[jr][jc]) {
                        moves.push({ tr: jr, tc: jc, jump: { r: nr, c: nc } });
                    }
                }
            }
        });
        return moves;
    }

    function getAllLegalMoves(b, color) {
        let moves = [];
        let anyJump = false;
        for (let r=0; r<8; r++) {
            for (let c=0; c<8; c++) {
                if (b[r][c] && b[r][c].c === color) {
                    let pMoves = getSimulatedPieceMoves(b, r, c);
                    pMoves.forEach(m => {
                        if (m.jump) anyJump = true;
                        moves.push({fr: r, fc: c, ...m});
                    });
                }
            }
        }
        if (anyJump) return moves.filter(m => m.jump);
        return moves;
    }

    function makeMove(b, move) {
        let p = b[move.fr][move.fc];
        let captured = null;
        let becameKing = false;
        b[move.tr][move.tc] = p;
        b[move.fr][move.fc] = null;
        if (move.jump) {
            captured = b[move.jump.r][move.jump.c];
            b[move.jump.r][move.jump.c] = null;
        }
        if (!p.k && ((move.tr === 0 && p.c === 'white') || (move.tr === 7 && p.c === 'black'))) {
            p.k = true;
            becameKing = true;
        }
        return { captured, becameKing };
    }

    function unmakeMove(b, move, undoData) {
        let p = b[move.tr][move.tc];
        if (undoData.becameKing) p.k = false;
        b[move.fr][move.fc] = p;
        b[move.tr][move.tc] = null;
        if (move.jump && undoData.captured) {
            b[move.jump.r][move.jump.c] = undoData.captured;
        }
    }

    // GRANDMASTER UCHUN KUCHAYTIRILGAN BAHOLASH TIZIMI
    function evaluateBoard(b) {
        let blackScore = 0;
        let whiteScore = 0;

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let p = b[r][c];
                if (p) {
                    let val = 0;
                    if (p.k) {
                        val = 300; // Damka eng katta qadrga ega
                    } else {
                        val = 100; // Oddiy tosh
                        // Toshni oldinga siljitishga undaymiz
                        if (p.c === 'black') {
                            val += (r * 5);
                            if (r === 0) val += 30; // Qora o'z orqa qatorini qattiq himoya qiladi
                        } else {
                            val += ((7 - r) * 5);
                            if (r === 7) val += 30; // Oqlar ham shunday
                        }
                    }

                    // Markaz va chekkalar strategiyasi
                    if (c === 0 || c === 7) val += 15; // Chekkalar himoyalangan
                    else if (c >= 2 && c <= 5 && r >= 3 && r <= 4) val += 20; // Markaziy xavfsiz pozitsiyalar

                    if (p.c === 'black') blackScore += val;
                    else whiteScore += val;
                }
            }
        }

        // Agar oq toshlar umuman qolmasa, bot aniq yutganini tushunib eng oxirgi zarbani beradi
        if (whiteScore === 0) return 99999;
        if (blackScore === 0) return -99999;

        return blackScore - whiteScore;
    }

    let nodesEvaluated = 0;
    function minimax(b, depth, alpha, beta, isMaximizing) {
        nodesEvaluated++;
        // Juda uzoq hisoblab qotib qolmasligi uchun maksimal tugun chegarasi
        if (depth === 0 || nodesEvaluated > 300000) {
            return evaluateBoard(b);
        }

        let color = isMaximizing ? 'black' : 'white';
        let moves = getAllLegalMoves(b, color);

        if (moves.length === 0) return isMaximizing ? -9999 : 9999;

        if (isMaximizing) {
            let maxEval = -Infinity;
            for (let move of moves) {
                let undoData = makeMove(b, move);
                let ev = minimax(b, depth - 1, alpha, beta, false);
                unmakeMove(b, move, undoData);
                maxEval = Math.max(maxEval, ev);
                alpha = Math.max(alpha, ev);
                if (beta <= alpha) break; // Qolgan keraksiz yo'llarni qirqib tashlaymiz
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (let move of moves) {
                let undoData = makeMove(b, move);
                let ev = minimax(b, depth - 1, alpha, beta, true);
                unmakeMove(b, move, undoData);
                minEval = Math.min(minEval, ev);
                beta = Math.min(beta, ev);
                if (beta <= alpha) break;
            }
            return minEval;
        }
    }

    function aiMove() {
        let moves = getAllLegalMoves(board, 'black');
        if (moves.length === 0) { document.getElementById('status').innerText = "G'alaba! Siz yutdingiz."; return; }

        let depthLimit = 1;
        if (currentLevel === 2) depthLimit = 4;
        else if (currentLevel === 3) depthLimit = 6;
        else if (currentLevel === 4) depthLimit = 8; // Grandmaster endi juda aqlli va 8 qadam bilan xatosiz o'ynaydi

        let bestMove = null;

        if (currentLevel === 1) {
            bestMove = moves[Math.floor(Math.random() * moves.length)];
        } else {
            let bestScore = -Infinity;
            nodesEvaluated = 0;
            let bestMoves = [];

            for (let move of moves) {
                let undoData = makeMove(board, move);
                let score = minimax(board, depthLimit - 1, -Infinity, Infinity, false);
                unmakeMove(board, move, undoData);

                if (score > bestScore) {
                    bestScore = score;
                    bestMoves = [move];
                } else if (score === bestScore) {
                    bestMoves.push(move);
                }
            }
            bestMove = bestMoves[Math.floor(Math.random() * bestMoves.length)];
        }

        executeMove(bestMove.fr, bestMove.fc, bestMove);
    }

    function toggleModal(s) { document.getElementById('levelModal').style.display = s ? 'flex' : 'none'; }
    function selectLevel(l, n) { currentLevel = l; document.getElementById('currentLevelDisplay').innerText = "Daraja: " + n; toggleModal(false); resetGame(); }
    function resetGame() {
        document.querySelectorAll('.piece').forEach(p => p.remove());
        initBoard();
        turn = 'white';
        selectedCell = null; hints = [];
        document.getElementById('status').innerText = "Sizning navbatingiz";
        renderBoard();
    }

    initBoard(); renderBoard();
</script>
</body>
</html>